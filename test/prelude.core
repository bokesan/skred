--
-- prelude.f
--
-- Standard utility functions.
--
-- All the character functions assume ASCII encoding.
--

stdin = _READ (_STD_PORT 0);
-- out_std s = cons (_STD_PORT 1) s;
-- out_err s = cons (_STD_PORT 2) s;
-- out_file f s = cons (output f) s;

error msg = _ERROR msg;

max x y	       =  if x <= y then y else x;
min x y	       =  if x <= y then x else y;
negate x       =  0 - x;
abs x	       =  if x < 0 then negate x else x;
subtract x y   =  y - x;
even x	       =  x % 2 == 0;
odd	       =  not . even;

gcd x y	       =  if x==0 && y==0 then
		     error "Prelude.gcd: gcd 0 0 is undefined"
		  else
		     gcd1 (abs x) (abs y);
	gcd1 x y       =  if y==0 then x
		          else gcd1 y (x % y);

id x	       =  x;
const c x      =  c;
flip f x y     =  f y x;

not x	       =  if x then False else True;
and x y	       =  if x then y else False;
or x y	       =  if x then True else y;
otherwise      =  True;

null	       =  _LISTCASE True (\h t -> False);
head	       =  _LISTCASE (_ERROR 0) (\h t -> h);
tail	       =  _LISTCASE (_ERROR 0) (\h t -> t);
last xs	       =  _LISTCASE (_ERROR 0)
	             (\x xs -> _LISTCASE x (\u1 u2 -> last xs) xs)
		     xs;
init xs	       =  _LISTCASE (_ERROR 0)
		     (\x xs -> _LISTCASE [] (\u1 u2 -> x : init xs) xs)
		     xs;
length xs      =  _LISTCASE 0 (\y ys -> 1 + length ys) xs;



-- until       :: (a -> Bool) -> (a -> a) -> a -> a
until p f x    =  if p x then x else until p f (f x);

-- isDigit isLower isSpace :: Char -> Bool
isDigit c = '0' <= c && c <= '9';
isLower c = 'a' <= c && c <= 'z';
isSpace c = c == ' ' || c == '\n';

-- digit_to_int :: Char -> Int
-- digit_to_int c = code c - 48;
digit_to_int c = c - 48;

-- digit_to_char :: Int -> Char
-- digit_to_char n = chr (n + 48);
digit_to_char n = 48 + n;


-- string_to_integer :: String -> (Int,String)
string_to_integer c =
   letrec
      s2i r cs =
         _LISTCASE
            (r : cs)
            (\d ds -> if isDigit d then
                         s2i (10*r + digit_to_int d) ds
                      else
                         r : cs)
            cs
   in
      _LISTCASE
            (_ERROR 0)  -- empty string
            (\hd tl -> if hd == '-' then
                          _LISTCASE (_ERROR 0)
                            (\hr tr -> negate hr : tr)
                            tl
                       else if isDigit hd then
                          s2i (digit_to_int hd) tl
                       else
                          _ERROR 0)
            (dropWhile isSpace c);


-- showsInt :: Int -> String -> String
showsInt n s =
  compare0 ('-' : i2s_ (negate n) s)
           ('0' : s)
           (i2s_ n s)
           n;
	i2s_ n result =
	  if zero n then result
          else i2s_ (n / 10) (digit_to_char (n % 10) : result);


showInt n = showsInt n "";


-- append :: [a] -> [a] -> [a]
append xs ys = append_r ys xs;
append_r ys xs = _LISTCASE ys (\h t -> h : append_r ys t) xs;
append_r2 ys xs = _LISTCASE ys (\h t -> snoc (append_r ys t) h) xs;

-- reverse :: [a] -> [a]
reverse xs = rev_ [] xs;
      rev_ rs xs = _LISTCASE rs (\h t -> rev_ (h:rs) t) xs;
      rev_2 rs xs = _LISTCASE rs (\h t -> rev_ (snoc rs h) t) xs;


-- concat :: [[a]] -> [a]
concat = foldr append [];

-- map :: (a -> b) -> [a] -> [b]
map f = _LISTCASE [] (\h t -> f h : map f t);
-- map2 f = _LISTCASE [] (\h t -> snoc (map f t) (f h));

-- filter :: (a -> Bool) -> [a] -> [a]
filter p =
   _LISTCASE
      []
      (\h t -> if p h then h : filter p t
	       else filter p t);
filter2 p =
   _LISTCASE
      []
      (\h t -> if p h then snoc (filter2 p t) h
	       else filter2 p t);

-- any, all :: (a -> Bool) -> [a] -> Bool
any p = foldr (\x r -> if p x then True else r) False;
all p = foldr (\x r -> if p x then r else False) True;

-- foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f a = _LISTCASE a (\h t -> foldl f (f a h) t);

-- foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f a = _LISTCASE a (\h t -> f h (foldr f a t));

-- foldl1 :: (a -> a -> a) -> [a] -> a
foldl1 f = _LISTCASE (_ERROR 0) (\h t -> foldl f h t);

-- foldr1 :: (a -> a -> a) -> [a] -> a
foldr1 f =
   _LISTCASE (_ERROR 0)
     (\y ys -> _LISTCASE y (\d1 d2 -> f y (foldr1 f ys)) ys);


-- format :: String -> [any] -> String
format f a =
   if
      null f then []
   else if
      head f == '~' then
      		let ch = head (tail f)
      		in (if
		      ch == 's' then
      		         head a ++ format (tail (tail f)) (tail a)
                    else if
		      ch == 'd' then
      		         showInt (head a) ++
      		         format (tail (tail f)) (tail a)
                    else _ERROR 0)
   else
      head f : format (tail f) a;


-- take :: Int -> [a] -> [a]
take n xs =
   compare0
      (_ERROR 0)
      []
      (_LISTCASE [] (\h t -> h : take (pred n) t) xs)
      n;

-- drop :: Int -> [a] -> [a]
drop n xs =
   compare0
      (_ERROR 0)
      xs
      (_LISTCASE [] (\h t -> drop (pred n) t) xs)
      n;

-- takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile p = _LISTCASE [] (\h t -> if p h then h : takeWhile p t
				    else []);

-- dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile p xs = _LISTCASE [] (\h t -> if p h then dropWhile p t else xs) xs;

-- iterate :: (a -> a) -> a -> [a]
iterate f x = x : iterate f (f x);


enumFrom = iterate succ;
enumFromTo a b = takeWhile (\ n -> b >= n) (enumFrom a);


-- zipWith :: [a] -> [b] -> [c]
zipWith f xs ys =
   _LISTCASE []
      (\x xs -> _LISTCASE []
		   (\y ys -> f x y : zipWith f xs ys)
		   ys)
      xs;
